import { GraphQLClient } from 'graphql-request'
import * as Dom from 'graphql-request/dist/types.dom'
import gql from 'graphql-tag'

export type Maybe<T> = T | null
export type InputMaybe<T> = Maybe<T>
export type Exact<T extends { [key: string]: unknown }> = {
    [K in keyof T]: T[K]
}
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>
}
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>
}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
    ID: string
    String: string
    Boolean: boolean
    Int: number
    Float: number
    /**
     * Define a Relay Cursor type:
     * https://relay.dev/graphql/connections.htm#sec-Cursor
     */
    Cursor: any
    /** The builtin Time type */
    Time: any
}

export type Block = Node & {
    __typename?: 'Block'
    authorID: Scalars['String']
    duration: Scalars['Int']
    id: Scalars['ID']
    part: Part
    partID: Scalars['ID']
    pitch: Scalars['Int']
    speaker: Scalars['String']
    speed: Scalars['Float']
    texts: Scalars['String']
    volume: Scalars['Float']
}

/**
 * BlockWhereInput is used for filtering Block objects.
 * Input was generated by ent.
 */
export type BlockWhereInput = {
    and?: InputMaybe<Array<BlockWhereInput>>
    /** author_id field predicates */
    authorID?: InputMaybe<Scalars['String']>
    authorIDContains?: InputMaybe<Scalars['String']>
    authorIDContainsFold?: InputMaybe<Scalars['String']>
    authorIDEqualFold?: InputMaybe<Scalars['String']>
    authorIDGT?: InputMaybe<Scalars['String']>
    authorIDGTE?: InputMaybe<Scalars['String']>
    authorIDHasPrefix?: InputMaybe<Scalars['String']>
    authorIDHasSuffix?: InputMaybe<Scalars['String']>
    authorIDIn?: InputMaybe<Array<Scalars['String']>>
    authorIDLT?: InputMaybe<Scalars['String']>
    authorIDLTE?: InputMaybe<Scalars['String']>
    authorIDNEQ?: InputMaybe<Scalars['String']>
    authorIDNotIn?: InputMaybe<Array<Scalars['String']>>
    /** duration field predicates */
    duration?: InputMaybe<Scalars['Int']>
    durationGT?: InputMaybe<Scalars['Int']>
    durationGTE?: InputMaybe<Scalars['Int']>
    durationIn?: InputMaybe<Array<Scalars['Int']>>
    durationLT?: InputMaybe<Scalars['Int']>
    durationLTE?: InputMaybe<Scalars['Int']>
    durationNEQ?: InputMaybe<Scalars['Int']>
    durationNotIn?: InputMaybe<Array<Scalars['Int']>>
    /** part edge predicates */
    hasPart?: InputMaybe<Scalars['Boolean']>
    hasPartWith?: InputMaybe<Array<PartWhereInput>>
    /** id field predicates */
    id?: InputMaybe<Scalars['ID']>
    idContainsFold?: InputMaybe<Scalars['ID']>
    idEqualFold?: InputMaybe<Scalars['ID']>
    idGT?: InputMaybe<Scalars['ID']>
    idGTE?: InputMaybe<Scalars['ID']>
    idIn?: InputMaybe<Array<Scalars['ID']>>
    idLT?: InputMaybe<Scalars['ID']>
    idLTE?: InputMaybe<Scalars['ID']>
    idNEQ?: InputMaybe<Scalars['ID']>
    idNotIn?: InputMaybe<Array<Scalars['ID']>>
    not?: InputMaybe<BlockWhereInput>
    or?: InputMaybe<Array<BlockWhereInput>>
    /** part_id field predicates */
    partID?: InputMaybe<Scalars['ID']>
    partIDContains?: InputMaybe<Scalars['ID']>
    partIDContainsFold?: InputMaybe<Scalars['ID']>
    partIDEqualFold?: InputMaybe<Scalars['ID']>
    partIDGT?: InputMaybe<Scalars['ID']>
    partIDGTE?: InputMaybe<Scalars['ID']>
    partIDHasPrefix?: InputMaybe<Scalars['ID']>
    partIDHasSuffix?: InputMaybe<Scalars['ID']>
    partIDIn?: InputMaybe<Array<Scalars['ID']>>
    partIDLT?: InputMaybe<Scalars['ID']>
    partIDLTE?: InputMaybe<Scalars['ID']>
    partIDNEQ?: InputMaybe<Scalars['ID']>
    partIDNotIn?: InputMaybe<Array<Scalars['ID']>>
    /** pitch field predicates */
    pitch?: InputMaybe<Scalars['Int']>
    pitchGT?: InputMaybe<Scalars['Int']>
    pitchGTE?: InputMaybe<Scalars['Int']>
    pitchIn?: InputMaybe<Array<Scalars['Int']>>
    pitchLT?: InputMaybe<Scalars['Int']>
    pitchLTE?: InputMaybe<Scalars['Int']>
    pitchNEQ?: InputMaybe<Scalars['Int']>
    pitchNotIn?: InputMaybe<Array<Scalars['Int']>>
    /** speaker field predicates */
    speaker?: InputMaybe<Scalars['String']>
    speakerContains?: InputMaybe<Scalars['String']>
    speakerContainsFold?: InputMaybe<Scalars['String']>
    speakerEqualFold?: InputMaybe<Scalars['String']>
    speakerGT?: InputMaybe<Scalars['String']>
    speakerGTE?: InputMaybe<Scalars['String']>
    speakerHasPrefix?: InputMaybe<Scalars['String']>
    speakerHasSuffix?: InputMaybe<Scalars['String']>
    speakerIn?: InputMaybe<Array<Scalars['String']>>
    speakerLT?: InputMaybe<Scalars['String']>
    speakerLTE?: InputMaybe<Scalars['String']>
    speakerNEQ?: InputMaybe<Scalars['String']>
    speakerNotIn?: InputMaybe<Array<Scalars['String']>>
    /** speed field predicates */
    speed?: InputMaybe<Scalars['Float']>
    speedGT?: InputMaybe<Scalars['Float']>
    speedGTE?: InputMaybe<Scalars['Float']>
    speedIn?: InputMaybe<Array<Scalars['Float']>>
    speedLT?: InputMaybe<Scalars['Float']>
    speedLTE?: InputMaybe<Scalars['Float']>
    speedNEQ?: InputMaybe<Scalars['Float']>
    speedNotIn?: InputMaybe<Array<Scalars['Float']>>
    /** texts field predicates */
    texts?: InputMaybe<Scalars['String']>
    textsContains?: InputMaybe<Scalars['String']>
    textsContainsFold?: InputMaybe<Scalars['String']>
    textsEqualFold?: InputMaybe<Scalars['String']>
    textsGT?: InputMaybe<Scalars['String']>
    textsGTE?: InputMaybe<Scalars['String']>
    textsHasPrefix?: InputMaybe<Scalars['String']>
    textsHasSuffix?: InputMaybe<Scalars['String']>
    textsIn?: InputMaybe<Array<Scalars['String']>>
    textsLT?: InputMaybe<Scalars['String']>
    textsLTE?: InputMaybe<Scalars['String']>
    textsNEQ?: InputMaybe<Scalars['String']>
    textsNotIn?: InputMaybe<Array<Scalars['String']>>
    /** volume field predicates */
    volume?: InputMaybe<Scalars['Float']>
    volumeGT?: InputMaybe<Scalars['Float']>
    volumeGTE?: InputMaybe<Scalars['Float']>
    volumeIn?: InputMaybe<Array<Scalars['Float']>>
    volumeLT?: InputMaybe<Scalars['Float']>
    volumeLTE?: InputMaybe<Scalars['Float']>
    volumeNEQ?: InputMaybe<Scalars['Float']>
    volumeNotIn?: InputMaybe<Array<Scalars['Float']>>
}

/**
 * CreateBlockInput is used for create Block object.
 * Input was generated by ent.
 */
export type CreateBlockInput = {
    authorID: Scalars['String']
    duration: Scalars['Int']
    partID: Scalars['ID']
    pitch: Scalars['Int']
    speaker: Scalars['String']
    speed: Scalars['Float']
    texts: Scalars['String']
    volume: Scalars['Float']
}

/**
 * CreatePartInput is used for create Part object.
 * Input was generated by ent.
 */
export type CreatePartInput = {
    authorID: Scalars['String']
    blockIDs?: InputMaybe<Array<Scalars['ID']>>
    name: Scalars['String']
    workID: Scalars['ID']
}

/**
 * CreateUserInput is used for create User object.
 * Input was generated by ent.
 */
export type CreateUserInput = {
    googleID: Scalars['String']
    point?: InputMaybe<Scalars['Int']>
    stripeID?: InputMaybe<Scalars['String']>
    workIDs?: InputMaybe<Array<Scalars['ID']>>
}

/**
 * CreateWorkInput is used for create Work object.
 * Input was generated by ent.
 */
export type CreateWorkInput = {
    authorID: Scalars['ID']
    createdAt?: InputMaybe<Scalars['Time']>
    name?: InputMaybe<Scalars['String']>
    partIDs?: InputMaybe<Array<Scalars['ID']>>
}

export type Mutation = {
    __typename?: 'Mutation'
    createBlock?: Maybe<Block>
    createPart?: Maybe<Part>
    createUser?: Maybe<User>
    createWork?: Maybe<Work>
    updateWork?: Maybe<Work>
}

export type MutationCreateBlockArgs = {
    input: CreateBlockInput
}

export type MutationCreatePartArgs = {
    input: CreatePartInput
}

export type MutationCreateUserArgs = {
    input: CreateUserInput
}

export type MutationCreateWorkArgs = {
    input: CreateWorkInput
}

export type MutationUpdateWorkArgs = {
    input: UpdateWorkInput
}

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
    /** The id of the object. */
    id: Scalars['ID']
}

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
    /** Specifies an ascending order for a given `orderBy` argument. */
    Asc = 'ASC',
    /** Specifies a descending order for a given `orderBy` argument. */
    Desc = 'DESC',
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
    __typename?: 'PageInfo'
    /** When paginating forwards, the cursor to continue. */
    endCursor?: Maybe<Scalars['Cursor']>
    /** When paginating forwards, are there more items? */
    hasNextPage: Scalars['Boolean']
    /** When paginating backwards, are there more items? */
    hasPreviousPage: Scalars['Boolean']
    /** When paginating backwards, the cursor to continue. */
    startCursor?: Maybe<Scalars['Cursor']>
}

export type Part = Node & {
    __typename?: 'Part'
    authorID: Scalars['String']
    blocks?: Maybe<Array<Block>>
    id: Scalars['ID']
    name: Scalars['String']
    work: Work
    workID: Scalars['ID']
}

/**
 * PartWhereInput is used for filtering Part objects.
 * Input was generated by ent.
 */
export type PartWhereInput = {
    and?: InputMaybe<Array<PartWhereInput>>
    /** author_id field predicates */
    authorID?: InputMaybe<Scalars['String']>
    authorIDContains?: InputMaybe<Scalars['String']>
    authorIDContainsFold?: InputMaybe<Scalars['String']>
    authorIDEqualFold?: InputMaybe<Scalars['String']>
    authorIDGT?: InputMaybe<Scalars['String']>
    authorIDGTE?: InputMaybe<Scalars['String']>
    authorIDHasPrefix?: InputMaybe<Scalars['String']>
    authorIDHasSuffix?: InputMaybe<Scalars['String']>
    authorIDIn?: InputMaybe<Array<Scalars['String']>>
    authorIDLT?: InputMaybe<Scalars['String']>
    authorIDLTE?: InputMaybe<Scalars['String']>
    authorIDNEQ?: InputMaybe<Scalars['String']>
    authorIDNotIn?: InputMaybe<Array<Scalars['String']>>
    /** blocks edge predicates */
    hasBlocks?: InputMaybe<Scalars['Boolean']>
    hasBlocksWith?: InputMaybe<Array<BlockWhereInput>>
    /** work edge predicates */
    hasWork?: InputMaybe<Scalars['Boolean']>
    hasWorkWith?: InputMaybe<Array<WorkWhereInput>>
    /** id field predicates */
    id?: InputMaybe<Scalars['ID']>
    idContainsFold?: InputMaybe<Scalars['ID']>
    idEqualFold?: InputMaybe<Scalars['ID']>
    idGT?: InputMaybe<Scalars['ID']>
    idGTE?: InputMaybe<Scalars['ID']>
    idIn?: InputMaybe<Array<Scalars['ID']>>
    idLT?: InputMaybe<Scalars['ID']>
    idLTE?: InputMaybe<Scalars['ID']>
    idNEQ?: InputMaybe<Scalars['ID']>
    idNotIn?: InputMaybe<Array<Scalars['ID']>>
    /** name field predicates */
    name?: InputMaybe<Scalars['String']>
    nameContains?: InputMaybe<Scalars['String']>
    nameContainsFold?: InputMaybe<Scalars['String']>
    nameEqualFold?: InputMaybe<Scalars['String']>
    nameGT?: InputMaybe<Scalars['String']>
    nameGTE?: InputMaybe<Scalars['String']>
    nameHasPrefix?: InputMaybe<Scalars['String']>
    nameHasSuffix?: InputMaybe<Scalars['String']>
    nameIn?: InputMaybe<Array<Scalars['String']>>
    nameLT?: InputMaybe<Scalars['String']>
    nameLTE?: InputMaybe<Scalars['String']>
    nameNEQ?: InputMaybe<Scalars['String']>
    nameNotIn?: InputMaybe<Array<Scalars['String']>>
    not?: InputMaybe<PartWhereInput>
    or?: InputMaybe<Array<PartWhereInput>>
    /** work_id field predicates */
    workID?: InputMaybe<Scalars['ID']>
    workIDContains?: InputMaybe<Scalars['ID']>
    workIDContainsFold?: InputMaybe<Scalars['ID']>
    workIDEqualFold?: InputMaybe<Scalars['ID']>
    workIDGT?: InputMaybe<Scalars['ID']>
    workIDGTE?: InputMaybe<Scalars['ID']>
    workIDHasPrefix?: InputMaybe<Scalars['ID']>
    workIDHasSuffix?: InputMaybe<Scalars['ID']>
    workIDIn?: InputMaybe<Array<Scalars['ID']>>
    workIDLT?: InputMaybe<Scalars['ID']>
    workIDLTE?: InputMaybe<Scalars['ID']>
    workIDNEQ?: InputMaybe<Scalars['ID']>
    workIDNotIn?: InputMaybe<Array<Scalars['ID']>>
}

export type Query = {
    __typename?: 'Query'
    blocks: Array<Block>
    getUserByGoogleId?: Maybe<User>
    getUserById?: Maybe<User>
    getWorkById?: Maybe<Work>
    /** Fetches an object given its ID. */
    node?: Maybe<Node>
    /** Lookup nodes by a list of IDs. */
    nodes: Array<Maybe<Node>>
    parts: Array<Part>
    users: Array<User>
    works: Array<Work>
}

export type QueryGetUserByGoogleIdArgs = {
    googleId: Scalars['ID']
}

export type QueryGetUserByIdArgs = {
    id: Scalars['ID']
}

export type QueryGetWorkByIdArgs = {
    id: Scalars['ID']
}

export type QueryNodeArgs = {
    id: Scalars['ID']
}

export type QueryNodesArgs = {
    ids: Array<Scalars['ID']>
}

/**
 * UpdateBlockInput is used for update Block object.
 * Input was generated by ent.
 */
export type UpdateBlockInput = {
    authorID?: InputMaybe<Scalars['String']>
    duration?: InputMaybe<Scalars['Int']>
    partID?: InputMaybe<Scalars['ID']>
    pitch?: InputMaybe<Scalars['Int']>
    speaker?: InputMaybe<Scalars['String']>
    speed?: InputMaybe<Scalars['Float']>
    texts?: InputMaybe<Scalars['String']>
    volume?: InputMaybe<Scalars['Float']>
}

/**
 * UpdatePartInput is used for update Part object.
 * Input was generated by ent.
 */
export type UpdatePartInput = {
    addBlockIDs?: InputMaybe<Array<Scalars['ID']>>
    authorID?: InputMaybe<Scalars['String']>
    clearBlocks?: InputMaybe<Scalars['Boolean']>
    name?: InputMaybe<Scalars['String']>
    removeBlockIDs?: InputMaybe<Array<Scalars['ID']>>
    workID?: InputMaybe<Scalars['ID']>
}

/**
 * UpdateUserInput is used for update User object.
 * Input was generated by ent.
 */
export type UpdateUserInput = {
    addWorkIDs?: InputMaybe<Array<Scalars['ID']>>
    clearWorks?: InputMaybe<Scalars['Boolean']>
    googleID?: InputMaybe<Scalars['String']>
    point?: InputMaybe<Scalars['Int']>
    removeWorkIDs?: InputMaybe<Array<Scalars['ID']>>
    stripeID?: InputMaybe<Scalars['String']>
}

/**
 * UpdateWorkInput is used for update Work object.
 * Input was generated by ent.
 */
export type UpdateWorkInput = {
    addPartIDs?: InputMaybe<Array<Scalars['ID']>>
    authorID?: InputMaybe<Scalars['ID']>
    clearParts?: InputMaybe<Scalars['Boolean']>
    createdAt?: InputMaybe<Scalars['Time']>
    name?: InputMaybe<Scalars['String']>
    removePartIDs?: InputMaybe<Array<Scalars['ID']>>
}

export type User = Node & {
    __typename?: 'User'
    googleID: Scalars['String']
    id: Scalars['ID']
    point: Scalars['Int']
    stripeID: Scalars['String']
    works?: Maybe<Array<Work>>
}

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
    and?: InputMaybe<Array<UserWhereInput>>
    /** google_id field predicates */
    googleID?: InputMaybe<Scalars['String']>
    googleIDContains?: InputMaybe<Scalars['String']>
    googleIDContainsFold?: InputMaybe<Scalars['String']>
    googleIDEqualFold?: InputMaybe<Scalars['String']>
    googleIDGT?: InputMaybe<Scalars['String']>
    googleIDGTE?: InputMaybe<Scalars['String']>
    googleIDHasPrefix?: InputMaybe<Scalars['String']>
    googleIDHasSuffix?: InputMaybe<Scalars['String']>
    googleIDIn?: InputMaybe<Array<Scalars['String']>>
    googleIDLT?: InputMaybe<Scalars['String']>
    googleIDLTE?: InputMaybe<Scalars['String']>
    googleIDNEQ?: InputMaybe<Scalars['String']>
    googleIDNotIn?: InputMaybe<Array<Scalars['String']>>
    /** works edge predicates */
    hasWorks?: InputMaybe<Scalars['Boolean']>
    hasWorksWith?: InputMaybe<Array<WorkWhereInput>>
    /** id field predicates */
    id?: InputMaybe<Scalars['ID']>
    idContainsFold?: InputMaybe<Scalars['ID']>
    idEqualFold?: InputMaybe<Scalars['ID']>
    idGT?: InputMaybe<Scalars['ID']>
    idGTE?: InputMaybe<Scalars['ID']>
    idIn?: InputMaybe<Array<Scalars['ID']>>
    idLT?: InputMaybe<Scalars['ID']>
    idLTE?: InputMaybe<Scalars['ID']>
    idNEQ?: InputMaybe<Scalars['ID']>
    idNotIn?: InputMaybe<Array<Scalars['ID']>>
    not?: InputMaybe<UserWhereInput>
    or?: InputMaybe<Array<UserWhereInput>>
    /** point field predicates */
    point?: InputMaybe<Scalars['Int']>
    pointGT?: InputMaybe<Scalars['Int']>
    pointGTE?: InputMaybe<Scalars['Int']>
    pointIn?: InputMaybe<Array<Scalars['Int']>>
    pointLT?: InputMaybe<Scalars['Int']>
    pointLTE?: InputMaybe<Scalars['Int']>
    pointNEQ?: InputMaybe<Scalars['Int']>
    pointNotIn?: InputMaybe<Array<Scalars['Int']>>
    /** stripe_id field predicates */
    stripeID?: InputMaybe<Scalars['String']>
    stripeIDContains?: InputMaybe<Scalars['String']>
    stripeIDContainsFold?: InputMaybe<Scalars['String']>
    stripeIDEqualFold?: InputMaybe<Scalars['String']>
    stripeIDGT?: InputMaybe<Scalars['String']>
    stripeIDGTE?: InputMaybe<Scalars['String']>
    stripeIDHasPrefix?: InputMaybe<Scalars['String']>
    stripeIDHasSuffix?: InputMaybe<Scalars['String']>
    stripeIDIn?: InputMaybe<Array<Scalars['String']>>
    stripeIDLT?: InputMaybe<Scalars['String']>
    stripeIDLTE?: InputMaybe<Scalars['String']>
    stripeIDNEQ?: InputMaybe<Scalars['String']>
    stripeIDNotIn?: InputMaybe<Array<Scalars['String']>>
}

export type Work = Node & {
    __typename?: 'Work'
    author: User
    authorID: Scalars['ID']
    createdAt: Scalars['Time']
    id: Scalars['ID']
    name: Scalars['String']
    parts?: Maybe<Array<Part>>
}

/**
 * WorkWhereInput is used for filtering Work objects.
 * Input was generated by ent.
 */
export type WorkWhereInput = {
    and?: InputMaybe<Array<WorkWhereInput>>
    /** author_id field predicates */
    authorID?: InputMaybe<Scalars['ID']>
    authorIDContains?: InputMaybe<Scalars['ID']>
    authorIDContainsFold?: InputMaybe<Scalars['ID']>
    authorIDEqualFold?: InputMaybe<Scalars['ID']>
    authorIDGT?: InputMaybe<Scalars['ID']>
    authorIDGTE?: InputMaybe<Scalars['ID']>
    authorIDHasPrefix?: InputMaybe<Scalars['ID']>
    authorIDHasSuffix?: InputMaybe<Scalars['ID']>
    authorIDIn?: InputMaybe<Array<Scalars['ID']>>
    authorIDLT?: InputMaybe<Scalars['ID']>
    authorIDLTE?: InputMaybe<Scalars['ID']>
    authorIDNEQ?: InputMaybe<Scalars['ID']>
    authorIDNotIn?: InputMaybe<Array<Scalars['ID']>>
    /** created_at field predicates */
    createdAt?: InputMaybe<Scalars['Time']>
    createdAtGT?: InputMaybe<Scalars['Time']>
    createdAtGTE?: InputMaybe<Scalars['Time']>
    createdAtIn?: InputMaybe<Array<Scalars['Time']>>
    createdAtLT?: InputMaybe<Scalars['Time']>
    createdAtLTE?: InputMaybe<Scalars['Time']>
    createdAtNEQ?: InputMaybe<Scalars['Time']>
    createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>
    /** author edge predicates */
    hasAuthor?: InputMaybe<Scalars['Boolean']>
    hasAuthorWith?: InputMaybe<Array<UserWhereInput>>
    /** parts edge predicates */
    hasParts?: InputMaybe<Scalars['Boolean']>
    hasPartsWith?: InputMaybe<Array<PartWhereInput>>
    /** id field predicates */
    id?: InputMaybe<Scalars['ID']>
    idContainsFold?: InputMaybe<Scalars['ID']>
    idEqualFold?: InputMaybe<Scalars['ID']>
    idGT?: InputMaybe<Scalars['ID']>
    idGTE?: InputMaybe<Scalars['ID']>
    idIn?: InputMaybe<Array<Scalars['ID']>>
    idLT?: InputMaybe<Scalars['ID']>
    idLTE?: InputMaybe<Scalars['ID']>
    idNEQ?: InputMaybe<Scalars['ID']>
    idNotIn?: InputMaybe<Array<Scalars['ID']>>
    /** name field predicates */
    name?: InputMaybe<Scalars['String']>
    nameContains?: InputMaybe<Scalars['String']>
    nameContainsFold?: InputMaybe<Scalars['String']>
    nameEqualFold?: InputMaybe<Scalars['String']>
    nameGT?: InputMaybe<Scalars['String']>
    nameGTE?: InputMaybe<Scalars['String']>
    nameHasPrefix?: InputMaybe<Scalars['String']>
    nameHasSuffix?: InputMaybe<Scalars['String']>
    nameIn?: InputMaybe<Array<Scalars['String']>>
    nameLT?: InputMaybe<Scalars['String']>
    nameLTE?: InputMaybe<Scalars['String']>
    nameNEQ?: InputMaybe<Scalars['String']>
    nameNotIn?: InputMaybe<Array<Scalars['String']>>
    not?: InputMaybe<WorkWhereInput>
    or?: InputMaybe<Array<WorkWhereInput>>
}

export type GetWorksQueryVariables = Exact<{
    id: Scalars['ID']
}>

export type GetWorksQuery = {
    __typename?: 'Query'
    getUserById?: {
        __typename?: 'User'
        id: string
        works?: Array<{
            __typename?: 'Work'
            id: string
            name: string
            createdAt: any
        }> | null
    } | null
}

export type GetUserFromGoogleIdQueryVariables = Exact<{
    googleId: Scalars['ID']
}>

export type GetUserFromGoogleIdQuery = {
    __typename?: 'Query'
    getUserByGoogleId?: { __typename?: 'User'; id: string } | null
}

export type CreateWorkMutationVariables = Exact<{
    authorID: Scalars['ID']
}>

export type CreateWorkMutation = {
    __typename?: 'Mutation'
    createWork?: {
        __typename?: 'Work'
        id: string
        name: string
        createdAt: any
    } | null
}

export type CreateUserMutationVariables = Exact<{
    googleID: Scalars['String']
}>

export type CreateUserMutation = {
    __typename?: 'Mutation'
    createUser?: { __typename?: 'User'; id: string; googleID: string } | null
}

export type UpdateWorkMutationVariables = Exact<{
    name: Scalars['String']
}>

export type UpdateWorkMutation = {
    __typename?: 'Mutation'
    updateWork?: { __typename?: 'Work'; name: string; id: string } | null
}

export const GetWorksDocument = gql`
    query getWorks($id: ID!) {
        getUserById(id: $id) {
            id
            works {
                id
                name
                createdAt
            }
        }
    }
`
export const GetUserFromGoogleIdDocument = gql`
    query getUserFromGoogleId($googleId: ID!) {
        getUserByGoogleId(googleId: $googleId) {
            id
        }
    }
`
export const CreateWorkDocument = gql`
    mutation createWork($authorID: ID!) {
        createWork(input: { authorID: $authorID }) {
            id
            name
            createdAt
        }
    }
`
export const CreateUserDocument = gql`
    mutation createUser($googleID: String!) {
        createUser(input: { googleID: $googleID }) {
            id
            googleID
        }
    }
`
export const UpdateWorkDocument = gql`
    mutation updateWork($name: String!) {
        updateWork(input: { name: $name }) {
            name
            id
        }
    }
`

export type SdkFunctionWrapper = <T>(
    action: (requestHeaders?: Record<string, string>) => Promise<T>,
    operationName: string,
    operationType?: string
) => Promise<T>

const defaultWrapper: SdkFunctionWrapper = (
    action,
    _operationName,
    _operationType
) => action()

export function getSdk(
    client: GraphQLClient,
    withWrapper: SdkFunctionWrapper = defaultWrapper
) {
    return {
        getWorks(
            variables: GetWorksQueryVariables,
            requestHeaders?: Dom.RequestInit['headers']
        ): Promise<GetWorksQuery> {
            return withWrapper(
                (wrappedRequestHeaders) =>
                    client.request<GetWorksQuery>(GetWorksDocument, variables, {
                        ...requestHeaders,
                        ...wrappedRequestHeaders,
                    }),
                'getWorks',
                'query'
            )
        },
        getUserFromGoogleId(
            variables: GetUserFromGoogleIdQueryVariables,
            requestHeaders?: Dom.RequestInit['headers']
        ): Promise<GetUserFromGoogleIdQuery> {
            return withWrapper(
                (wrappedRequestHeaders) =>
                    client.request<GetUserFromGoogleIdQuery>(
                        GetUserFromGoogleIdDocument,
                        variables,
                        { ...requestHeaders, ...wrappedRequestHeaders }
                    ),
                'getUserFromGoogleId',
                'query'
            )
        },
        createWork(
            variables: CreateWorkMutationVariables,
            requestHeaders?: Dom.RequestInit['headers']
        ): Promise<CreateWorkMutation> {
            return withWrapper(
                (wrappedRequestHeaders) =>
                    client.request<CreateWorkMutation>(
                        CreateWorkDocument,
                        variables,
                        { ...requestHeaders, ...wrappedRequestHeaders }
                    ),
                'createWork',
                'mutation'
            )
        },
        createUser(
            variables: CreateUserMutationVariables,
            requestHeaders?: Dom.RequestInit['headers']
        ): Promise<CreateUserMutation> {
            return withWrapper(
                (wrappedRequestHeaders) =>
                    client.request<CreateUserMutation>(
                        CreateUserDocument,
                        variables,
                        { ...requestHeaders, ...wrappedRequestHeaders }
                    ),
                'createUser',
                'mutation'
            )
        },
        updateWork(
            variables: UpdateWorkMutationVariables,
            requestHeaders?: Dom.RequestInit['headers']
        ): Promise<UpdateWorkMutation> {
            return withWrapper(
                (wrappedRequestHeaders) =>
                    client.request<UpdateWorkMutation>(
                        UpdateWorkDocument,
                        variables,
                        { ...requestHeaders, ...wrappedRequestHeaders }
                    ),
                'updateWork',
                'mutation'
            )
        },
    }
}

export type Sdk = ReturnType<typeof getSdk>
