// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type Block struct {
	ID       string  `json:"id"`
	AuthorID string  `json:"authorID"`
	Speed    float64 `json:"speed"`
	Speaker  string  `json:"speaker"`
	Volume   float64 `json:"volume"`
	Pitch    int     `json:"pitch"`
	Texts    string  `json:"texts"`
	Duration int     `json:"duration"`
	PartID   string  `json:"partID"`
	Part     *Part   `json:"part"`
}

func (Block) IsNode() {}

// BlockWhereInput is used for filtering Block objects.
// Input was generated by ent.
type BlockWhereInput struct {
	Not *BlockWhereInput   `json:"not,omitempty"`
	And []*BlockWhereInput `json:"and,omitempty"`
	Or  []*BlockWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// author_id field predicates
	AuthorID             *string  `json:"authorID,omitempty"`
	AuthorIDNeq          *string  `json:"authorIDNEQ,omitempty"`
	AuthorIDIn           []string `json:"authorIDIn,omitempty"`
	AuthorIDNotIn        []string `json:"authorIDNotIn,omitempty"`
	AuthorIDGt           *string  `json:"authorIDGT,omitempty"`
	AuthorIDGte          *string  `json:"authorIDGTE,omitempty"`
	AuthorIDLt           *string  `json:"authorIDLT,omitempty"`
	AuthorIDLte          *string  `json:"authorIDLTE,omitempty"`
	AuthorIDContains     *string  `json:"authorIDContains,omitempty"`
	AuthorIDHasPrefix    *string  `json:"authorIDHasPrefix,omitempty"`
	AuthorIDHasSuffix    *string  `json:"authorIDHasSuffix,omitempty"`
	AuthorIDEqualFold    *string  `json:"authorIDEqualFold,omitempty"`
	AuthorIDContainsFold *string  `json:"authorIDContainsFold,omitempty"`
	// speed field predicates
	Speed      *float64  `json:"speed,omitempty"`
	SpeedNeq   *float64  `json:"speedNEQ,omitempty"`
	SpeedIn    []float64 `json:"speedIn,omitempty"`
	SpeedNotIn []float64 `json:"speedNotIn,omitempty"`
	SpeedGt    *float64  `json:"speedGT,omitempty"`
	SpeedGte   *float64  `json:"speedGTE,omitempty"`
	SpeedLt    *float64  `json:"speedLT,omitempty"`
	SpeedLte   *float64  `json:"speedLTE,omitempty"`
	// speaker field predicates
	Speaker             *string  `json:"speaker,omitempty"`
	SpeakerNeq          *string  `json:"speakerNEQ,omitempty"`
	SpeakerIn           []string `json:"speakerIn,omitempty"`
	SpeakerNotIn        []string `json:"speakerNotIn,omitempty"`
	SpeakerGt           *string  `json:"speakerGT,omitempty"`
	SpeakerGte          *string  `json:"speakerGTE,omitempty"`
	SpeakerLt           *string  `json:"speakerLT,omitempty"`
	SpeakerLte          *string  `json:"speakerLTE,omitempty"`
	SpeakerContains     *string  `json:"speakerContains,omitempty"`
	SpeakerHasPrefix    *string  `json:"speakerHasPrefix,omitempty"`
	SpeakerHasSuffix    *string  `json:"speakerHasSuffix,omitempty"`
	SpeakerEqualFold    *string  `json:"speakerEqualFold,omitempty"`
	SpeakerContainsFold *string  `json:"speakerContainsFold,omitempty"`
	// volume field predicates
	Volume      *float64  `json:"volume,omitempty"`
	VolumeNeq   *float64  `json:"volumeNEQ,omitempty"`
	VolumeIn    []float64 `json:"volumeIn,omitempty"`
	VolumeNotIn []float64 `json:"volumeNotIn,omitempty"`
	VolumeGt    *float64  `json:"volumeGT,omitempty"`
	VolumeGte   *float64  `json:"volumeGTE,omitempty"`
	VolumeLt    *float64  `json:"volumeLT,omitempty"`
	VolumeLte   *float64  `json:"volumeLTE,omitempty"`
	// pitch field predicates
	Pitch      *int  `json:"pitch,omitempty"`
	PitchNeq   *int  `json:"pitchNEQ,omitempty"`
	PitchIn    []int `json:"pitchIn,omitempty"`
	PitchNotIn []int `json:"pitchNotIn,omitempty"`
	PitchGt    *int  `json:"pitchGT,omitempty"`
	PitchGte   *int  `json:"pitchGTE,omitempty"`
	PitchLt    *int  `json:"pitchLT,omitempty"`
	PitchLte   *int  `json:"pitchLTE,omitempty"`
	// texts field predicates
	Texts             *string  `json:"texts,omitempty"`
	TextsNeq          *string  `json:"textsNEQ,omitempty"`
	TextsIn           []string `json:"textsIn,omitempty"`
	TextsNotIn        []string `json:"textsNotIn,omitempty"`
	TextsGt           *string  `json:"textsGT,omitempty"`
	TextsGte          *string  `json:"textsGTE,omitempty"`
	TextsLt           *string  `json:"textsLT,omitempty"`
	TextsLte          *string  `json:"textsLTE,omitempty"`
	TextsContains     *string  `json:"textsContains,omitempty"`
	TextsHasPrefix    *string  `json:"textsHasPrefix,omitempty"`
	TextsHasSuffix    *string  `json:"textsHasSuffix,omitempty"`
	TextsEqualFold    *string  `json:"textsEqualFold,omitempty"`
	TextsContainsFold *string  `json:"textsContainsFold,omitempty"`
	// duration field predicates
	Duration      *int  `json:"duration,omitempty"`
	DurationNeq   *int  `json:"durationNEQ,omitempty"`
	DurationIn    []int `json:"durationIn,omitempty"`
	DurationNotIn []int `json:"durationNotIn,omitempty"`
	DurationGt    *int  `json:"durationGT,omitempty"`
	DurationGte   *int  `json:"durationGTE,omitempty"`
	DurationLt    *int  `json:"durationLT,omitempty"`
	DurationLte   *int  `json:"durationLTE,omitempty"`
	// part_id field predicates
	PartID             *string  `json:"partID,omitempty"`
	PartIDNeq          *string  `json:"partIDNEQ,omitempty"`
	PartIDIn           []string `json:"partIDIn,omitempty"`
	PartIDNotIn        []string `json:"partIDNotIn,omitempty"`
	PartIDGt           *string  `json:"partIDGT,omitempty"`
	PartIDGte          *string  `json:"partIDGTE,omitempty"`
	PartIDLt           *string  `json:"partIDLT,omitempty"`
	PartIDLte          *string  `json:"partIDLTE,omitempty"`
	PartIDContains     *string  `json:"partIDContains,omitempty"`
	PartIDHasPrefix    *string  `json:"partIDHasPrefix,omitempty"`
	PartIDHasSuffix    *string  `json:"partIDHasSuffix,omitempty"`
	PartIDEqualFold    *string  `json:"partIDEqualFold,omitempty"`
	PartIDContainsFold *string  `json:"partIDContainsFold,omitempty"`
	// part edge predicates
	HasPart     *bool             `json:"hasPart,omitempty"`
	HasPartWith []*PartWhereInput `json:"hasPartWith,omitempty"`
}

// CreateBlockInput is used for create Block object.
// Input was generated by ent.
type CreateBlockInput struct {
	AuthorID string  `json:"authorID"`
	Speed    float64 `json:"speed"`
	Speaker  string  `json:"speaker"`
	Volume   float64 `json:"volume"`
	Pitch    int     `json:"pitch"`
	Texts    string  `json:"texts"`
	Duration int     `json:"duration"`
	PartID   string  `json:"partID"`
}

// CreatePartInput is used for create Part object.
// Input was generated by ent.
type CreatePartInput struct {
	Name     string   `json:"name"`
	AuthorID string   `json:"authorID"`
	WorkID   string   `json:"workID"`
	BlockIDs []string `json:"blockIDs,omitempty"`
}

// CreateUserInput is used for create User object.
// Input was generated by ent.
type CreateUserInput struct {
	GoogleID string   `json:"googleID"`
	StripeID string   `json:"stripeID"`
	Point    int      `json:"point"`
	WorkIDs  []string `json:"workIDs,omitempty"`
}

// CreateWorkInput is used for create Work object.
// Input was generated by ent.
type CreateWorkInput struct {
	Name      string    `json:"name"`
	CreatedAt time.Time `json:"createdAt"`
	AuthorID  string    `json:"authorID"`
	PartIDs   []string  `json:"partIDs,omitempty"`
}

// Information about pagination in a connection.
// https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
type PageInfo struct {
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating backwards, the cursor to continue.
	StartCursor *string `json:"startCursor,omitempty"`
	// When paginating forwards, the cursor to continue.
	EndCursor *string `json:"endCursor,omitempty"`
}

type Part struct {
	ID       string   `json:"id"`
	Name     string   `json:"name"`
	WorkID   string   `json:"workID"`
	AuthorID string   `json:"authorID"`
	Work     *Work    `json:"work"`
	Blocks   []*Block `json:"blocks,omitempty"`
}

func (Part) IsNode() {}

// PartWhereInput is used for filtering Part objects.
// Input was generated by ent.
type PartWhereInput struct {
	Not *PartWhereInput   `json:"not,omitempty"`
	And []*PartWhereInput `json:"and,omitempty"`
	Or  []*PartWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// work_id field predicates
	WorkID             *string  `json:"workID,omitempty"`
	WorkIDNeq          *string  `json:"workIDNEQ,omitempty"`
	WorkIDIn           []string `json:"workIDIn,omitempty"`
	WorkIDNotIn        []string `json:"workIDNotIn,omitempty"`
	WorkIDGt           *string  `json:"workIDGT,omitempty"`
	WorkIDGte          *string  `json:"workIDGTE,omitempty"`
	WorkIDLt           *string  `json:"workIDLT,omitempty"`
	WorkIDLte          *string  `json:"workIDLTE,omitempty"`
	WorkIDContains     *string  `json:"workIDContains,omitempty"`
	WorkIDHasPrefix    *string  `json:"workIDHasPrefix,omitempty"`
	WorkIDHasSuffix    *string  `json:"workIDHasSuffix,omitempty"`
	WorkIDEqualFold    *string  `json:"workIDEqualFold,omitempty"`
	WorkIDContainsFold *string  `json:"workIDContainsFold,omitempty"`
	// author_id field predicates
	AuthorID             *string  `json:"authorID,omitempty"`
	AuthorIDNeq          *string  `json:"authorIDNEQ,omitempty"`
	AuthorIDIn           []string `json:"authorIDIn,omitempty"`
	AuthorIDNotIn        []string `json:"authorIDNotIn,omitempty"`
	AuthorIDGt           *string  `json:"authorIDGT,omitempty"`
	AuthorIDGte          *string  `json:"authorIDGTE,omitempty"`
	AuthorIDLt           *string  `json:"authorIDLT,omitempty"`
	AuthorIDLte          *string  `json:"authorIDLTE,omitempty"`
	AuthorIDContains     *string  `json:"authorIDContains,omitempty"`
	AuthorIDHasPrefix    *string  `json:"authorIDHasPrefix,omitempty"`
	AuthorIDHasSuffix    *string  `json:"authorIDHasSuffix,omitempty"`
	AuthorIDEqualFold    *string  `json:"authorIDEqualFold,omitempty"`
	AuthorIDContainsFold *string  `json:"authorIDContainsFold,omitempty"`
	// work edge predicates
	HasWork     *bool             `json:"hasWork,omitempty"`
	HasWorkWith []*WorkWhereInput `json:"hasWorkWith,omitempty"`
	// blocks edge predicates
	HasBlocks     *bool              `json:"hasBlocks,omitempty"`
	HasBlocksWith []*BlockWhereInput `json:"hasBlocksWith,omitempty"`
}

// UpdateBlockInput is used for update Block object.
// Input was generated by ent.
type UpdateBlockInput struct {
	AuthorID *string  `json:"authorID,omitempty"`
	Speed    *float64 `json:"speed,omitempty"`
	Speaker  *string  `json:"speaker,omitempty"`
	Volume   *float64 `json:"volume,omitempty"`
	Pitch    *int     `json:"pitch,omitempty"`
	Texts    *string  `json:"texts,omitempty"`
	Duration *int     `json:"duration,omitempty"`
	PartID   *string  `json:"partID,omitempty"`
}

// UpdatePartInput is used for update Part object.
// Input was generated by ent.
type UpdatePartInput struct {
	Name           *string  `json:"name,omitempty"`
	AuthorID       *string  `json:"authorID,omitempty"`
	WorkID         *string  `json:"workID,omitempty"`
	AddBlockIDs    []string `json:"addBlockIDs,omitempty"`
	RemoveBlockIDs []string `json:"removeBlockIDs,omitempty"`
	ClearBlocks    *bool    `json:"clearBlocks,omitempty"`
}

// UpdateUserInput is used for update User object.
// Input was generated by ent.
type UpdateUserInput struct {
	GoogleID      *string  `json:"googleID,omitempty"`
	StripeID      *string  `json:"stripeID,omitempty"`
	Point         *int     `json:"point,omitempty"`
	AddWorkIDs    []string `json:"addWorkIDs,omitempty"`
	RemoveWorkIDs []string `json:"removeWorkIDs,omitempty"`
	ClearWorks    *bool    `json:"clearWorks,omitempty"`
}

// UpdateWorkInput is used for update Work object.
// Input was generated by ent.
type UpdateWorkInput struct {
	Name          *string    `json:"name,omitempty"`
	CreatedAt     *time.Time `json:"createdAt,omitempty"`
	AuthorID      *string    `json:"authorID,omitempty"`
	AddPartIDs    []string   `json:"addPartIDs,omitempty"`
	RemovePartIDs []string   `json:"removePartIDs,omitempty"`
	ClearParts    *bool      `json:"clearParts,omitempty"`
}

type User struct {
	ID       string  `json:"id"`
	GoogleID string  `json:"googleID"`
	StripeID string  `json:"stripeID"`
	Point    int     `json:"point"`
	Works    []*Work `json:"works,omitempty"`
}

func (User) IsNode() {}

// UserWhereInput is used for filtering User objects.
// Input was generated by ent.
type UserWhereInput struct {
	Not *UserWhereInput   `json:"not,omitempty"`
	And []*UserWhereInput `json:"and,omitempty"`
	Or  []*UserWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// google_id field predicates
	GoogleID             *string  `json:"googleID,omitempty"`
	GoogleIDNeq          *string  `json:"googleIDNEQ,omitempty"`
	GoogleIDIn           []string `json:"googleIDIn,omitempty"`
	GoogleIDNotIn        []string `json:"googleIDNotIn,omitempty"`
	GoogleIDGt           *string  `json:"googleIDGT,omitempty"`
	GoogleIDGte          *string  `json:"googleIDGTE,omitempty"`
	GoogleIDLt           *string  `json:"googleIDLT,omitempty"`
	GoogleIDLte          *string  `json:"googleIDLTE,omitempty"`
	GoogleIDContains     *string  `json:"googleIDContains,omitempty"`
	GoogleIDHasPrefix    *string  `json:"googleIDHasPrefix,omitempty"`
	GoogleIDHasSuffix    *string  `json:"googleIDHasSuffix,omitempty"`
	GoogleIDEqualFold    *string  `json:"googleIDEqualFold,omitempty"`
	GoogleIDContainsFold *string  `json:"googleIDContainsFold,omitempty"`
	// stripe_id field predicates
	StripeID             *string  `json:"stripeID,omitempty"`
	StripeIDNeq          *string  `json:"stripeIDNEQ,omitempty"`
	StripeIDIn           []string `json:"stripeIDIn,omitempty"`
	StripeIDNotIn        []string `json:"stripeIDNotIn,omitempty"`
	StripeIDGt           *string  `json:"stripeIDGT,omitempty"`
	StripeIDGte          *string  `json:"stripeIDGTE,omitempty"`
	StripeIDLt           *string  `json:"stripeIDLT,omitempty"`
	StripeIDLte          *string  `json:"stripeIDLTE,omitempty"`
	StripeIDContains     *string  `json:"stripeIDContains,omitempty"`
	StripeIDHasPrefix    *string  `json:"stripeIDHasPrefix,omitempty"`
	StripeIDHasSuffix    *string  `json:"stripeIDHasSuffix,omitempty"`
	StripeIDEqualFold    *string  `json:"stripeIDEqualFold,omitempty"`
	StripeIDContainsFold *string  `json:"stripeIDContainsFold,omitempty"`
	// point field predicates
	Point      *int  `json:"point,omitempty"`
	PointNeq   *int  `json:"pointNEQ,omitempty"`
	PointIn    []int `json:"pointIn,omitempty"`
	PointNotIn []int `json:"pointNotIn,omitempty"`
	PointGt    *int  `json:"pointGT,omitempty"`
	PointGte   *int  `json:"pointGTE,omitempty"`
	PointLt    *int  `json:"pointLT,omitempty"`
	PointLte   *int  `json:"pointLTE,omitempty"`
	// works edge predicates
	HasWorks     *bool             `json:"hasWorks,omitempty"`
	HasWorksWith []*WorkWhereInput `json:"hasWorksWith,omitempty"`
}

type Work struct {
	ID        string    `json:"id"`
	Name      string    `json:"name"`
	CreatedAt time.Time `json:"createdAt"`
	AuthorID  string    `json:"authorID"`
	Author    *User     `json:"author"`
	Parts     []*Part   `json:"parts,omitempty"`
}

func (Work) IsNode() {}

// WorkWhereInput is used for filtering Work objects.
// Input was generated by ent.
type WorkWhereInput struct {
	Not *WorkWhereInput   `json:"not,omitempty"`
	And []*WorkWhereInput `json:"and,omitempty"`
	Or  []*WorkWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt      *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq   *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt    *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte   *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt    *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte   *time.Time   `json:"createdAtLTE,omitempty"`
	// author_id field predicates
	AuthorID             *string  `json:"authorID,omitempty"`
	AuthorIDNeq          *string  `json:"authorIDNEQ,omitempty"`
	AuthorIDIn           []string `json:"authorIDIn,omitempty"`
	AuthorIDNotIn        []string `json:"authorIDNotIn,omitempty"`
	AuthorIDGt           *string  `json:"authorIDGT,omitempty"`
	AuthorIDGte          *string  `json:"authorIDGTE,omitempty"`
	AuthorIDLt           *string  `json:"authorIDLT,omitempty"`
	AuthorIDLte          *string  `json:"authorIDLTE,omitempty"`
	AuthorIDContains     *string  `json:"authorIDContains,omitempty"`
	AuthorIDHasPrefix    *string  `json:"authorIDHasPrefix,omitempty"`
	AuthorIDHasSuffix    *string  `json:"authorIDHasSuffix,omitempty"`
	AuthorIDEqualFold    *string  `json:"authorIDEqualFold,omitempty"`
	AuthorIDContainsFold *string  `json:"authorIDContainsFold,omitempty"`
	// author edge predicates
	HasAuthor     *bool             `json:"hasAuthor,omitempty"`
	HasAuthorWith []*UserWhereInput `json:"hasAuthorWith,omitempty"`
	// parts edge predicates
	HasParts     *bool             `json:"hasParts,omitempty"`
	HasPartsWith []*PartWhereInput `json:"hasPartsWith,omitempty"`
}

// Possible directions in which to order a list of items when provided an `orderBy` argument.
type OrderDirection string

const (
	// Specifies an ascending order for a given `orderBy` argument.
	OrderDirectionAsc OrderDirection = "ASC"
	// Specifies a descending order for a given `orderBy` argument.
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
